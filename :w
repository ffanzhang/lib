#include "SegmentTree.cpp"
#include "Union.cpp"
#include <cstdlib>
#include <iostream>
#include <cstdint>
#include <cassert>
using namespace std;

void testSegmentTree() {
    std::vector<int> elements;
    for (int i = 0; i < 100; i++) {
        elements.push_back(i + 1);
    }
    Combine<int> *c = new MyMax<int>();
    SegmentTree<int, int> t1(elements, c);
    assert(t1.query(0, 100) == 100);
    assert(t1.query(0, 50) == 50);
    assert(t1.query(50, 100) == 100);

    /*
    Combine<int> *d = new Combine<int>();
    SegmentTree<int, int> t2(elements, d);
    assert(t2.query(0, 100) == 1);
    assert(t2.query(0, 50) == 1);
    assert(t2.query(50, 100) == 51);
    */

    SegmentTree<int, int> t3(elements, (new MySum<int>()));
    assert(t3.query(0, 100) == 5050);
    assert(t3.query(0, 50) == (50 * 51) / 2);
    for (int i = 1; i <= 100; i++) {
        assert(t3.query(0, i) == i * (i + 1) / 2);
    }
    Combine<__int128> *e= new MySum<__int128>();
//    SegmentTree<__int128, __int128> t4(elements, e);
}

template <class I, class T>
void testUnionHelper(Union<T> *u, I n) {
    assert(n > 9);
    u->merge(1, 2);
    assert(u->is_connected(1, 2) == true);
    u->merge(3, 4);
    assert(u->is_connected(3, 4) == true);
    assert(u->is_connected(1, 3) == false);
    u->merge(1, 3);
    assert(u->is_connected(1, 4) == true);
    assert(u->is_connected(1, 5) == false);
    assert(u->components() == n);
    for (I i = 0; i < n - 1; i++) {
        u->merge(i, i + 1);
    }
    assert(u->is_connected(0, n - 1) == true);
    assert(u->is_connected(n / 2, 0) == true);
    assert(u->components() == 1);
}

void testUnion() {
    int n = 10 + rand() % 100;
    
    Union<char> *u = new Union<char>(n);
    Union<int> *v = new UnionByRank<int>(n);
    Union<long long> *w = new UnionBySize<long long>(n);
    Union<__int128> *x = new Union<__int128>(n);

    testUnionHelper(u, n);
    testUnionHelper(v, 100);
    testUnionHelper(w, 100);
    testUnionHelper(x, 10 + rand() % 100);


}

int main() {
    testUnion();
    testSegmentTree();

    return 0;
}
